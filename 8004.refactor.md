# ERC-8004 Identity Registry — Refactor Notes

> **Version:** 2.0.0 → 3.0.0  
> **File:** `contracts/IdentityRegistryUpgradeable.sol`  
> **Date:** February 21, 2026

---

## Summary

The identity registry was extended to treat the **oracle contract address** as a first-class, typed, reserved field — following the exact same pattern already established for `agentWallet`. The goal was to make the registry the single authoritative source of truth for the agent ↔ oracle binding, eliminating a separate oracle whitelist in each oracle contract.

---

## What changed

### 1. New reserved key constant

```solidity
// Before — only one reserved key
bytes32 private constant RESERVED_AGENT_WALLET_KEY_HASH = keccak256("agentWallet");

// After — two reserved keys
bytes32 private constant RESERVED_AGENT_WALLET_KEY_HASH   = keccak256("agentWallet");
bytes32 private constant RESERVED_ORACLE_ADDRESS_KEY_HASH = keccak256("oracleAddress");
```

This prevents `oracleAddress` from being silently overwritten via the generic `setMetadata()` path.

---

### 2. `_requireNotReserved()` — new internal helper

Previously the reserved-key check was inlined in two places (`register` with metadata and `setMetadata`), each only guarding `agentWallet`. It is now extracted into a shared helper that guards both reserved keys:

```solidity
// Before — inlined, single key
require(keccak256(bytes(metadata[i].metadataKey)) != RESERVED_AGENT_WALLET_KEY_HASH, "reserved key");

// After — shared helper, both keys
function _requireNotReserved(string memory metadataKey) internal pure {
    bytes32 h = keccak256(bytes(metadataKey));
    require(h != RESERVED_AGENT_WALLET_KEY_HASH,   "reserved key: agentWallet");
    require(h != RESERVED_ORACLE_ADDRESS_KEY_HASH, "reserved key: oracleAddress");
}
```

All callers (`register` with metadata, `setMetadata`) now call `_requireNotReserved()` instead of the inline check.

---

### 3. New event: `OracleAddressSet`

```solidity
event OracleAddressSet(
    uint256 indexed agentId,
    address indexed oracleAddress,
    address indexed setBy
);
```

Provides a dedicated, queryable audit trail for every oracle binding and unbinding. Emitted on:
- `register(agentURI, metadata[], oracleAddress)` — initial binding
- `setOracleAddress(agentId, oracleAddress)` — post-registration update
- `_update(...)` on transfer — emitted with `address(0)` when the binding is cleared

---

### 4. New typed getter: `getOracleAddress()`

```solidity
function getOracleAddress(uint256 agentId) external view returns (address) {
    IdentityRegistryStorage storage $ = _getIdentityRegistryStorage();
    bytes memory data = $._metadata[agentId]["oracleAddress"];
    if (data.length == 0) return address(0);
    return address(bytes20(data));
}
```

Returns the oracle contract bound to an agent, or `address(0)` if unset. Follows the same storage encoding as `getAgentWallet()` — `abi.encodePacked(address)` stored as `bytes20`.

---

### 5. New typed setter: `setOracleAddress()`

```solidity
function setOracleAddress(uint256 agentId, address oracleAddress) external {
    // onlyOwner / approved operator check
    // ...
    $._metadata[agentId]["oracleAddress"] = abi.encodePacked(oracleAddress);
    emit OracleAddressSet(agentId, oracleAddress, msg.sender);
}
```

Allows the agent owner or an approved operator to update the oracle binding post-registration. Setting `address(0)` unbinds the oracle. No signature required (unlike `setAgentWallet`) because the oracle address is not a cryptographic proof of control — it is an administrative binding set by the NFT owner.

---

### 6. New `register()` overload — the one-shot enterprise path

```solidity
// New overload — Option A
function register(
    string memory agentURI,
    MetadataEntry[] memory metadata,
    address oracleAddress
) external returns (uint256 agentId)
```

Establishes five facts in a single transaction:

| Fact | Set by |
|---|---|
| Agent identity (ERC-721 token) | `_safeMint` |
| Agent card URI | `_setTokenURI` |
| `agentWallet` | `abi.encodePacked(msg.sender)` |
| Oracle contract binding | `abi.encodePacked(oracleAddress)` |
| Arbitrary capability metadata | loop over `MetadataEntry[]` |

Emits: `Registered`, `MetadataSet` (for agentWallet), `OracleAddressSet`, and one `MetadataSet` per metadata entry.

The three existing `register()` overloads (no args, URI only, URI + metadata) are unchanged.

---

### 7. `_update()` — clears `oracleAddress` on transfer

```solidity
// Before — only cleared agentWallet on transfer
if (from != address(0) && to != address(0)) {
    $._metadata[tokenId]["agentWallet"] = "";
    emit MetadataSet(tokenId, "agentWallet", "agentWallet", "");
}

// After — clears both reserved fields on transfer
if (from != address(0) && to != address(0)) {
    $._metadata[tokenId]["agentWallet"]   = "";
    $._metadata[tokenId]["oracleAddress"] = "";
    emit MetadataSet(tokenId, "agentWallet", "agentWallet", "");
    emit OracleAddressSet(tokenId, address(0), msg.sender);
}
```

This is a critical security property: the new owner of a transferred agent NFT cannot inherit access to the previous owner's oracle contracts. They must re-bind their own wallet and oracle before the oracle's `onlyRegisteredOracle` modifier will pass.

---

### 8. Version bump

```solidity
// Before
function getVersion() external pure returns (string memory) { return "2.0.0"; }

// After
function getVersion() external pure returns (string memory) { return "3.0.0"; }
```

---

## What did NOT change

| Item | Status |
|---|---|
| Storage layout (`IdentityRegistryStorage` struct) | **Unchanged** — `oracleAddress` lives in the existing `_metadata` mapping under key `"oracleAddress"`, zero new storage slots |
| ERC-7201 storage slot constant | **Unchanged** |
| UUPS upgrade path | **Unaffected** — no new storage slots means no layout collision risk |
| `agentWallet` behaviour | **Unchanged** — EIP-712 signed setter, cleared on transfer, reserved key |
| All three existing `register()` overloads | **Unchanged** |
| `setMetadata()` / `getMetadata()` | **Unchanged** in interface — only the inline reserved-key check was refactored into `_requireNotReserved()` |
| `ReputationRegistryUpgradeable` | **Unaffected** |

---

## Downstream impact

### `IIdentityRegistry.sol` — new interface file

A minimal interface was extracted for consumption by oracle contracts:

```solidity
interface IIdentityRegistry {
    function getAgentWallet(uint256 agentId) external view returns (address);
    function getOracleAddress(uint256 agentId) external view returns (address);
    function getMetadata(uint256 agentId, string memory metadataKey) external view returns (bytes memory);
    function ownerOf(uint256 agentId) external view returns (address);
}
```

### `CodeReviewerOracle.sol` / `CodeApproverOracle.sol`

- Removed: `mapping(address => bool) public isOracle` whitelist
- Removed: `addOracle()` / `removeOracle()` owner functions
- Added: `IIdentityRegistry public identityRegistry` state variable
- Added: `onlyRegisteredOracle(uint256 agentId)` modifier
- Changed: all `fulfill*()` functions now take `agentId` as first parameter
- Changed: constructors now require `address identityRegistry_`
- Changed: `ReviewResult` / `ApprovalResult` structs now store `agentId` for permanent attribution

The oracle authorization check is now:

```solidity
modifier onlyRegisteredOracle(uint256 agentId) {
    require(identityRegistry.getAgentWallet(agentId) == msg.sender, ...);
    require(identityRegistry.getOracleAddress(agentId) == address(this), ...);
    _;
}
```

**Registration in the identity registry is now the oracle authorization.** No separate administrative step is needed after deploying an oracle contract.

